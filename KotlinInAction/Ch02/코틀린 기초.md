# Ch02 코틀린 기초
<br>

## 📌 학습 목표
```
• 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
• 제어 구조
• 스마트 캐스트
• 예외 던지기와 예외 집기
```
<br>
<br>

## 2.1  기본 요소: 함수와 변수
### 2.1.1 Hello, World!
```kotlin
fun main(args: Array<String>) {
    println("hello, world!")
}
```
1) 함수를 선언할 때 fun 키워드 사용
2) 파라미터 이름 뒤에 그 파라미터의 타입을 작성(변수 선언 시에도 마찬가지)
3) 함수를 최상위 수준에 정의 할 수 O <br>
   반드시 클래스 안에 함수를 넣어야 할 필요 X
4) 배열도 일반적인 클래스 <br>
   코틀린에는 배열 처리를 위한 문법이 따로 존재하지 X
5) System.out.println 대신 println
6) 줄 끝에 세미콜론 필요 X
<br>
<br>
<br>

### 2.1.2 함수
### 결과를 반환하는 함수의 경우 반환값 타입의 위치
```kotlin
fun max(a: Int, b: Int) : Int {
   return if (a > b) a else b
}
```
`fun 함수이름 (파라미터) : 리턴타입` <br>
→ 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 위치 <br>
  　괄호와 반환 타입 사이를 콜론으로 구분
 
 ```
 Cf) statement vs expression
statement는 값을 만들어 내고 다른 식의 하위 요소로 계산에 포함될 수 있는 반면, 
expression은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 
코틀린에서는 루프를 제외한 대부분의 제어 구조가 expression이다.
 ```
 <br>
 
 ### 식이 본문인 함수
 - `블록이 본문인 함수` → 본문이 중괄호로 둘러싸인 함수 <br>
  `식이 본문인 함수` → 등호와 식으로 이루어진 함수 <br>
  
 - 위의 예제와 같이 if식 하나로만 이루어진 경우, 중괄호를 없애고 return을 제거하면서 등호를 이용하면 더 간결하게 함수를 표현할 수 있다
```kotlin
fun max(a: Int, b: Int) : Int = if (a > b) a else b
```
<br>

→ 반환 타입 생략 시 더욱 간략하게 만들 수 있다
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 반환 타입을 생략할 수 있는 이유 <br>
    → `타입 추론`: 식이 본문인 함수의 경우, 반환 타입을 적지 않아도 컴파일러가 식의 결과 타입을 함수 반환 타입으로 알아서 정해준다 <br>
    → 식이 본문인 함수의 반환 타입만 생략 가능!

<br>
<br>
<br>

### 2.1.3 변수
- 코틀린에서는 타입 지정을 생략하는 경우가 많기 때문에 타입 생략 시에도 식과 변수 선언을 구별하기 위해 `val`키워드로 변수 선언을 시작한다
- 변수 이름 뒤에 타입을 명시하거나 타입 지정을 생략하는 것도 가능하다
<br>

→ 타입 지정 생략(컴파일러가 초기화 식의 타입을 변수 타입으로 지정)
```kotlin
val question = 
        "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42
```
→ 변수 이름 뒤에 타입 명시
```kotlin
val answer : Int = 42
```

### 변경 가능한 변수와 변경 불가능한 변수
- 변수 선언 시 사용하는 키워드
    - `val`(값을 뜻하는 value에서 따옴)
        - 변경 불가능한(immutable) 참조를 저장하는 변수
        - 초기화 후 재대입 불가능
        - 자바의 final
    - `var`(변수를 뜻하는 variable에서 따옴)
        - 변경 가능한(mutable) 참조
        - 값이 바뀔 수 있음
        - 자바의 일반 변수
  
 
val question =일바 
val question = 
