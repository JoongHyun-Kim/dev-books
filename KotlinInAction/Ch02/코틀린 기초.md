# Ch02 코틀린 기초
<br>

## 📌 학습 목표
```
• 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
• 제어 구조
• 스마트 캐스트
• 예외 던지기와 예외 집기
```
<br>
<br>

## 2.1  기본 요소: 함수와 변수
```kotlin
fun main(args: Array<String>) {
    println("hello, world!")
}
```
1) 함수를 선언할 때 fun 키워드 사용
2) 파라미터 이름 뒤에 그 파라미터의 타입을 작성(변수 선언 시에도 마찬가지)
3) 함수를 최상위 수준에 정의 할 수 O <br>
   반드시 클래스 안에 함수를 넣어야 할 필요 X
4) 배열도 일반적인 클래스 <br>
   코틀린에는 배열 처리를 위한 문법이 따로 존재하지 X
5) System.out.println 대신 println
6) 줄 끝에 세미콜론 필요 X
<br>

### 결과를 반환하는 함수의 경우 반환값 타입의 위치
```kotlin
fun max(a: Int, b: Int) : Int {
   return if (a > b) a else b
}
```
`fun 함수이름 (파라미터) : 리턴타입` <br>
→ 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 위치 <br>
  　괄호와 반환 타입 사이를 콜론으로 구분
 
 ```
 Cf) statement vs expression
statement는 값을 만들어 내고 다른 식의 하위 요소로 계산에 포함될 수 있는 반면, 
expression은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 
코틀린에서는 루프를 제외한 대부분의 제어 구조가 expression이다.
 ```
 
 ### 식이 본문인 함수
 - `블록이 본문인 함수` → 본문이 중괄호로 둘러싸인 함수 <br>
  `식이 본문인 함수` → 등호와 식으로 이루어진 함수 <br>
  
 - 위의 예제와 같이 if식 하나로만 이루어진 경우, 중괄호를 없애고 return을 제거하면서 등호를 이용하면 더 간결하게 함수를 표현할 수 있다
```kotlin
fun max(a: Int, b: Int) : Int = if (a > b) a else b
```
<br>

→ 반환 타입 생략 시 더욱 간략하게 만들 수 있다
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 반환 타입을 생략할 수 있는 이유 <br>
    → `타입 추론`: 식이 본문인 함수의 경우, 반환 타입을 적지 않아도 컴파일러가 식의 결과 타입을 함수 반환 타입으로 알아서 정해준다 <br>
    → 식이 본문인 함수의 반환 타입만 생략 가능!
