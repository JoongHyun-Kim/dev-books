# Ch02 코틀린 기초
## 📌 학습 목표
```
• 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
• 제어 구조
• 스마트 캐스트
• 예외 던지기와 예외 집기
```
<br>
<br>
<br>

## 2.1  기본 요소: 함수와 변수
### 2.1.1 Hello, World!
```kotlin
fun main(args: Array<String>) {
    println("hello, world!")
}
```
1) 함수를 선언할 때 fun 키워드 사용
2) 파라미터 이름 뒤에 그 파라미터의 타입을 작성(변수 선언 시에도 마찬가지)
3) 함수를 최상위 수준에 정의 할 수 O <br>
   반드시 클래스 안에 함수를 넣어야 할 필요 X
4) 배열도 일반적인 클래스 <br>
   코틀린에는 배열 처리를 위한 문법이 따로 존재하지 X
5) System.out.println 대신 println
6) 줄 끝에 세미콜론 필요 X
<br>
<br>

### 2.1.2 함수
### 결과를 반환하는 함수의 경우 반환값 타입의 위치
```kotlin
fun max(a: Int, b: Int) : Int {
   return if (a > b) a else b
}
```
`fun 함수이름 (파라미터) : 리턴타입` <br>
→ 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 위치 <br>
  　괄호와 반환 타입 사이를 콜론으로 구분
 
 ```
 Cf) statement vs expression
statement는 값을 만들어 내고 다른 식의 하위 요소로 계산에 포함될 수 있는 반면, 
expression은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어 내지 않는다. 
코틀린에서는 루프를 제외한 대부분의 제어 구조가 expression이다.
 ```
 <br>
 
 ### 식이 본문인 함수
 - `블록이 본문인 함수` → 본문이 중괄호로 둘러싸인 함수 <br>
  `식이 본문인 함수` → 등호와 식으로 이루어진 함수 <br>
  
 - 위의 예제와 같이 if식 하나로만 이루어진 경우, 중괄호를 없애고 return을 제거하면서 등호를 이용하면 더 간결하게 함수를 표현할 수 있다
```kotlin
fun max(a: Int, b: Int) : Int = if (a > b) a else b
```
<br>

→ 반환 타입 생략 시 더욱 간략하게 만들 수 있다
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

- 반환 타입을 생략할 수 있는 이유 <br>
    → `타입 추론`: 식이 본문인 함수의 경우, 반환 타입을 적지 않아도 컴파일러가 식의 결과 타입을 함수 반환 타입으로 알아서 정해준다 <br>
    → 식이 본문인 함수의 반환 타입만 생략 가능!

<br>
<br>
<br>

### 2.1.3 변수
- 코틀린에서는 타입 지정을 생략하는 경우가 많기 때문에 타입 생략 시에도 식과 변수 선언을 구별하기 위해 `val`키워드로 변수 선언을 시작한다
- 변수 이름 뒤에 타입을 명시하거나 타입 지정을 생략하는 것도 가능하다
<br>

→ 타입 지정 생략(컴파일러가 초기화 식의 타입을 변수 타입으로 지정)
```kotlin
val question = 
        "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42
```
→ 변수 이름 뒤에 타입 명시
```kotlin
val answer : Int = 42
```
<br>

### 변경 가능한 변수와 변경 불가능한 변수
- 변수 선언 시 사용하는 키워드
    - `val`(값을 뜻하는 value에서 따옴)
        - 변경 불가능한(immutable) 참조를 저장하는 변수
        - 초기화 후 재대입 불가능
        - 자바의 final
    - `var`(변수를 뜻하는 variable에서 따옴)
        - 변경 가능한(mutable) 참조
        - 값이 바뀔 수 있음
        - 자바의 일반 변수

- 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 필요 시에만 var로 변경
- val 변수는 블록 실행할 때 한 번만 초기화되어야 하는데, 조건에 따라 val 값을 여러 값으로 초기화할 수도 있다
```kotlin
val message : String
if (canPerformOperation()) {
    message = "Success"
    //...
}
else {
    message = "Failed"
}
```
<br>

- val 참조 자체는 불변이지만, 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다
```kotlin
val languages = arrayListOf("Java") //불변참조 선언
languages.add("Kotlin") //참조가 가리키는 객체 내부 변경
```
<br>
<br>
<br>

## 2.2 클래스와 프로퍼티
```kotlin
class Person(val name: String)
```
- value object(값 객체): 코드 없이 데이터만 저장하는 클래스
- publc 생략 가능
<br>
<br>

### 2.2.1 프로퍼티
- 자바는 필드와 접근자를 묶어 프로퍼티라고 칭하며 필드에 접근하고 값을 변경하기 위해 접근자 메소드(getter, setter)를 사용한다. <br>
  코틀린은 프로퍼티를 기본 기능으로 제공하고 프로퍼티가 자바의 필드와 접근자 메소드를 완전히 대신한다.
- `val`로 선언한 프로퍼티는 읽기 전용, `var`로 선언한 프로퍼티는 변경 가능 
- 코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이루어진 디폴트 접근자를 제공
- 코틀린에서는 getter, setter 함수 대신 프로퍼티 직접 사용 가능
```kotlin
/* Java */
System.out.println(person.getName());
person.serMarried(false);

/* Kotlin */
println(person.name)
person.isMarried = false
```
<br>
<br>

### 2.2.2 커스텀 접근자
```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}
```
→ 직사각형이 정사각형인지를 별도의 필드에 저장할 필요X <br>
→ 프로퍼티에 접근할 때마다 getter가 프로퍼티 값을 매번 다시 계산
<br>
<br>

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
- 모든 코틀린 파일의 맨 앞에 `package문`을 넣을 수 있는데, 그러면 그 파일 안에 있는 모든 선언이 해당 패키지에 들어간다.
- 같은 패키지 안에서는 다른 파일에서 정의한 선언도 사용할 수 있지만, 다른 패키지에서 정의한 선언을 사용하려면 `import`를 해와야 한다.
<br>
<br>
<br>

## 2.3 선택 표현과 처리: enum과 when
### 2.3.1 enum 클래스 정의
- 코틀린에서 `enum`은 soft keyword <br>
→ class 앞에 쓸 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용 가능
- enum은 단순히 값만 열거하는 것X enum 클래스 안에도 프로퍼티나 메소드 정의 가능
- enum클래스 안에 메소드 정의하는 경우, enum 상수목록과 메소드 정의 사이에 세미콜론 필수(kotlin에서 세미콜론이 필수인 유일한 경우)
