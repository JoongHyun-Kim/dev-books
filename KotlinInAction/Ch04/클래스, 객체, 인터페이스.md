# Ch04 클래스, 객체, 인터페이스
## 📌 학습목표
```
• 클래스와 인터페이스
• 뻔하지 않은 생성자와 프로퍼티
• 데이터 클래스
• 클래스 위임
• object 키워드 사용
```
<br>
<br>

## 4.1 클래스 계층 정의
1. 코틀린에서 `클래스 계층`을 정의하는 방식을 자바와 비교해보고,
2. 코틀린의 `가시성`과 `접근 변경자`에 대해 살펴보며,
3. 코틀린에 새로 도입된 `sealed 변경자`에 대해 알아보자!
<br>
<br>

### 4.1.1 코틀린 인터페이스
- **코틀린 인터페이스**는 자바 8 인터페이스와 비슷한데, 코틀린 인터페이스에는 추상 메소드뿐만 아니라 구현된 메소드도 정의할 수 있다.  
  단, 인터페이스에는 아무런 필드도 들어갈 수 없다.
<br>
  
```kotlin
interface Clickable {
  fun click()
}
```
```kotlin
class Button : Clickable {
  override fun click() = println("I was clicked")\
}

>>> Button().click()
I was clicked
```
-  자바의 extends와 implements 키워드 대신, 코틀린은 **클래스 이름** 뒤에 **콜론**을 붙이고 **인터페이스 또는 클래스 이름**을 적어   
   `인터페이스 구현`과 `클래스 확장`을 모두 핸들링할 수 있다.
- 클래스는 인터페이스를 개수 제한 없이 자유롭게 구현할 수 있지만, 클래스는 하나만 확장할 수 있다.
- 자바의 @Override annotation과 비슷한 코틀린의 `override 변경자`는 상위 클래스 또는 인터페이스에 있는 프로퍼티나 메소드를   
  오버라이드한다는 표시다.  
  → 코틀린에서는 실수로 상위 클래스의 메소드를 오버라이드하는 경우를 방지하기 위해 **override 변경자를 반드시 사용해야 한다!**
<br>
<br>

```kotlin
interface Clickable {
  fun click() //일반 메소드 선언
  fun showOff() = println("I'm clickable!") //default 구현이 있는 메소드
```
 → showOff()처럼 default 구현을 제공할 수도 있다.  
　자바는 default 키워드를 써줘야 하지만, 코틀린은 **default 키워드 없이** 메소드 본문을 적어주면 된다.
